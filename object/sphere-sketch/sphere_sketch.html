<!DOCTYPE html>
<html lang="en">
	<head>
		<title>sketch sphere</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #CCC;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #000;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button { 
				color: #f00;
				font-weight: bold; text-decoration: underline; cursor: pointer 
			}
		</style>		
		
	</head>

	<body>
		<div id="info">
		<a href="http://threejs.org" target="_blank">three.js</a> - sphere
		</div>

		<script src="./ThreeJS/three.min.js"></script>
		<script src="./ThreeJS/OBJLoader.js"></script>
		<script src="./ThreeJS/ShaderMaterial.js" type = "module"></script>	
		<!-- <script src="./sphere_sketch.js"></script> -->
		
		
		<script id="hatch_vShaderCode" type="x-shader/x-vertex">
			varying vec2 vUv;
			void main(void) {
			  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			  vUv = uv;
			}
		</script>
		
		<script id="compose_vShaderCode" type="x-shader/x-vertex">
			varying vec2 vUv;
			void main() {
			  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			  vUv = uv;
			}
		</script>
		

		<script id="hatch_fShaderCode" type="x-shader/x-fragment">
			uniform sampler2D aTexture;
			varying vec2 vUv;

			//void main(void) {gl_FragColor = texture2D(aTexture, vUv);}	
			
			uniform sampler2D bakedshadow;
			uniform sampler2D hatch0;
			uniform sampler2D hatch1;
			uniform sampler2D hatch2;
		
			float shade(const in float shading, const in vec2 uv) {
			  float shadingFactor;
			  float stepSize = 1.0 / 3.0;
			  float alpha = 0.0;
			  float scaleWhite = 0.0;
			  float scaleHatch0 = 0.0;
			  float scaleHatch1 = 0.0;
			  float scaleHatch2 = 0.0;
			  if (shading <= stepSize) {
				alpha = 3.0 * shading;
				scaleHatch1 = alpha;
				scaleHatch2 = 1.0 - alpha;
			  }
			  else if (shading > stepSize && shading <= 2.0 * stepSize) {
				alpha = 3.0 * (shading - stepSize);
				scaleHatch0 = alpha;
				scaleHatch1 = 1.0 - alpha;
			  }
			  else if (shading > 2.0 * stepSize) {
				alpha = 3.0 * (shading - stepSize * 2.0);
				scaleWhite = alpha;
				scaleHatch0 = 1.0 - alpha;
			  }
			  shadingFactor = scaleWhite + 
				scaleHatch0 * texture2D(hatch0, uv).r +
				scaleHatch1 * texture2D(hatch1, uv).r +
				scaleHatch2 * texture2D(hatch2, uv).r;
			  return shadingFactor;
			}
			
			void main() {
			  vec2 uv = vUv * 15.0;
			  vec2 uv2 = vUv.yx * 10.0;
			  float shading = texture2D(aTexture, vUv).r + 0.1;
			  float crossedShading = shade(shading, uv) * shade(shading, uv2) * 0.6 + 0.4;
			  gl_FragColor = vec4(vec3(crossedShading), 1.0);
			}

		</script>	
		
		<script id="compose_fShaderCode" type="x-shader/x-fragment">
			uniform sampler2D depthtexture;
			uniform sampler2D normaltexture;
			uniform sampler2D hatchtexture;

			varying vec2 vUv;

			float planeDistance(const in vec3 positionA, const in vec3 normalA, 
								const in vec3 positionB, const in vec3 normalB) {
			  vec3 positionDelta = positionB-positionA;
			  float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));
			  return planeDistanceDelta;
			}

			void main() {
			  float depthCenter = texture2D(depthtexture, vUv).r;
			  float px = 1.0/800.0;

			  vec3 leftpos = vec3(vUv.s - px, vUv.t, 1.0 - texture2D(depthtexture, vec2(vUv.s - px, vUv.t)).r);
			  vec3 rightpos = vec3(vUv.s + px, vUv.t, 1.0 - texture2D(depthtexture, vec2(vUv.s + px, vUv.t)).r);
			  vec3 uppos = vec3(vUv.s, vUv.t - px, 1.0 - texture2D(depthtexture, vec2(vUv.s, vUv.t - px)).r);
			  vec3 downpos = vec3(vUv.s, vUv.t + px, 1.0 - texture2D(depthtexture, vec2(vUv.s, vUv.t + px)).r);

			  vec3 leftnor = texture2D(normaltexture, vec2(vUv.s - px, vUv.t)).xyz;
			  vec3 rightnor = texture2D(normaltexture, vec2(vUv.s + px, vUv.t)).xyz;
			  vec3 upnor = texture2D(normaltexture, vec2(vUv.s, vUv.t - px)).xyz;
			  vec3 downnor = texture2D(normaltexture, vec2(vUv.s, vUv.t + px)).xyz;

			  vec2 planeDist = vec2(
				planeDistance(leftpos, leftnor, rightpos, rightnor),
				planeDistance(uppos, upnor, downpos, downnor));

			  float planeEdge = 2.5 * length(planeDist);
			  planeEdge = 1.0 - 0.5 * smoothstep(0.0, depthCenter, planeEdge);

			  float normEdge = max(length(leftnor - rightnor), length(upnor - downnor));
			  normEdge = 1.0 - 0.5 * smoothstep(0.0, 0.5, normEdge); 

			  float edge= planeEdge * normEdge;
			  vec4 hatch = texture2D(hatchtexture, vUv);
			  gl_FragColor = vec4(vec3(hatch * edge), 1.0);
			}
		</script>
		
		<script>
			init_obj_scene();
			load_obj_model();
			init_texture();
			init_com_scene();
			render_cycle();


			var objScene,objCamera;
			var comScene,comCamera;
			var depthTexture, normalTexture, hatchTexture;
			var keyLight,renderer;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			
			function init_obj_scene() {	
				// setup scene
				objScene = new THREE.Scene();

				// setup light
				var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 1.0 );//颜色 强度
				objScene.add( ambientLight );
				keyLight = new THREE.SpotLight(0xffffff, 1, 5000, Math.PI / 6, 25);
                keyLight.position.set(-100, 100, 100);
                keyLight.target.position.set(0, 0, 0);
                objScene.add(keyLight);
				
				// setup objCamera
				objCamera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 2000 );
				objCamera.position.x = 0;
				objCamera.position.y = 0;
				objCamera.position.z = 250;	
				objScene.add( objCamera );
								
				//setup renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );	
				renderer.setClearColor(0xEEEEEE, 1.0);
								
				//layout	
				container = document.createElement( 'div' );
				container.appendChild( renderer.domElement );
				document.body.appendChild( container );	
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			
			
			function load_obj_model(){
				var manager = new THREE.LoadingManager();
					manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};
				var loader = new THREE.OBJLoader();
				loader.load( 'models/sphere.obj', afterLoad, onProgress, onError );
							
				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
					}
				};
				var onError = function ( xhr ) {
				};
		
				var object;
				function afterLoad( object ) {
					//object.traverse( function ( child ) {
					//	if ( child instanceof THREE.Mesh ) {
					//		child.material = mk_hatchMat();;//设置shader		
					//	}
					//} );
					//设置模型在场景中的位置
					object.position.x = 20;
					object.position.y = 0;
					object.position.z = 0;	
					objScene.add(object);
				}
			}
				
			function init_texture(){
				var pars = {
					minFilter: THREE.LinearFilter,
					magFilter: THREE.LinearFilter,
					format: THREE.RGBFormat,
					stencilBuffer: false
				}
				depthTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, pars);
				normalTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, pars);
				hatchTexture= new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, pars);			
			}
			
			
			function init_com_scene(){
				comScene = new THREE.Scene();
				comCamera = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, -10, 10);
				var composePlaneGeometry = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight);							
				var composePlaneMesh = new THREE.Mesh(composePlaneGeometry, mk_composeMat());//将前几步输出到 FrameBuffer (也就是WebGLRenderTarget)的结果作为这个矩形表面的贴图，
				comScene.add(composePlaneMesh);

			}

			
			function mk_hatchMat(){
				//var mytexture = THREE.ImageUtils.loadTexture('texture/sphere_baked.png');
				var mytexture = THREE.ImageUtils.loadTexture('texture/sphere_baked.png');
				var hatch0 = THREE.ImageUtils.loadTexture('texture/hatch_0.jpg');
				var hatch1 = THREE.ImageUtils.loadTexture('texture/hatch_1.jpg');
				var hatch2 = THREE.ImageUtils.loadTexture('texture/hatch_2.jpg');
			
				var uniPars = {
					aTexture:{type:'t', value: mytexture},
					hatch0:{type:'t', value: hatch0},
					hatch1:{type:'t', value: hatch1},
					hatch2:{type:'t', value: hatch2}
				};

				var material =  new THREE.ShaderMaterial({
					uniforms : uniPars,
				//	attributes:attributes,
					vertexShader:document.getElementById('hatch_vShaderCode').textContent,
					fragmentShader:document.getElementById('hatch_fShaderCode').textContent
				}); 
				return material;
			}
			
			function mk_composeMat(){

				var uniPars = {
					depthtexture:{type:'t', value: depthTexture },
					normaltexture:{type:'t', value: normalTexture},
					hatchtexture:{type:'t', value: hatchTexture}
				};
					
				var material =  new THREE.ShaderMaterial({
					uniforms : uniPars,
				//	attributes:attributes,
					vertexShader:document.getElementById('compose_vShaderCode').textContent,
					fragmentShader:document.getElementById('compose_fShaderCode').textContent
				}); 
				return material;
			}
	
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				objCamera.aspect = window.innerWidth / window.innerHeight;
				objCamera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				mouseX = ( event.clientX - windowHalfX ) ;
				mouseY = ( event.clientY - windowHalfY ) ;
			}


			
			////////渲染输出部分//////			
			function render_cycle() {
				requestAnimationFrame( render_cycle );
				render();
			}
			function render() {
				renderAnimate();
				renderDepth();
				renderNormal();
				renderHetch();
				
				compose();		
			}				
			function renderAnimate(){
				objCamera.position.x += ( mouseX - objCamera.position.x );
				objCamera.position.y += ( - mouseY - objCamera.position.y ) ;
				objCamera.lookAt( objScene.position );
			}
			function renderDepth(){				
				var depthMaterial = new THREE.MeshDepthMaterial();
				objScene.overrideMaterial = depthMaterial;
				renderer.setClearColor('#000000');
				renderer.clearTarget(depthTexture, true, true);
				renderer.render(objScene, objCamera, depthTexture);
			}			
			function renderNormal(){
				var normalMaterial = new THREE.MeshNormalMaterial();
				objScene.overrideMaterial = normalMaterial;
				renderer.setClearColor('#000000');
				renderer.clearTarget(normalTexture, true, true);
				renderer.render(objScene, objCamera, normalTexture);
			}		
			function renderHetch(){
				var hatchMaterial = mk_hatchMat();
				objScene.overrideMaterial = hatchMaterial;
				renderer.setClearColor('#ffffff');
				renderer.clearTarget(hatchTexture, true, true);
				renderer.render(objScene, objCamera, hatchTexture);
			}
			
			function compose(){
	
				 renderer.render(comScene, comCamera);
			}
			
			
			
			
			
			function test(){
				var cube = new THREE.CubeGeometry(25, 25, 25);
				var material = new THREE.MeshDepthMaterial();
				var mesh = new THREE.Mesh(cube, material);
				
				objScene.add(mesh);
			}		
					
			//var textureLoader = new THREE.TextureLoader( manager );
			//var mytexture = textureLoader.load( textureName );
			//var hatch0 = textureLoader.load();
			//var hatch1 = textureLoader.load('texture/hatch_1.jpg');
			//var hatch2 = textureLoader.load('texture/hatch_2.jpg');
		</script>
			
		

	</body>
</html>



